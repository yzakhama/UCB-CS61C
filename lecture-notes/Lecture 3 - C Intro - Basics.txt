If you are starting a new project where performance matters use either Go or Rust
- Rust, "C-but-safe": By the time your C is (theoretically) correct with all necessary checks, it should be no faster than rust
- Go, "Concurrency": Practical concurrent programming to take advantage of modern multi-core microprocessors

Compilation:
	A C compiler is a program that takes a C program and outputs an architecture-specific machine code (string of 0s and 1s)
	- Unlike Java, which converts to architecture-independent bytecode that may then be compiled by a just-in-time compiler (JIT) -> Java has both a compiler and an interpreter
	- Unlike Python environments, which converts to a byte code at runtime

	-> These differ mainly in exactly when your program is converted to low-level machine instructions ("levels of interpretation")

	For C, generally a two part process of compilation .c files to .o files (machine code object files), then linking the .o files into executables
	- Assembling is also done, but is hidden, i.e. done automatically, by default

C Pre-Processor (CPP)
	foo.c -> CPP -> foo.i -> Compiler
	- C source files first pass through macro processor, CPP, before compiler sees code
	- CPP replaces comments with a single space
	- CPP commands begin with '#'
		- #include inserts .h file into output
		- #define defines a constant
		- #if/#endif -> conditionally include text
	- use -save-temps option to gcc to see result of preprocessing

	CPP macros:
		- You often see C preprocessor macros defined to create small "functions"
			- but they are not actual functions, instead it just changes the text of the program
			- in fact, all #define does is string replacement

		Warning:
			#define min(X,Y) ((X) < (Y) ? (X) : (Y))

			next = min(w, foo(z))

			!! foo gets called 2 times here (because #define only replaces the text)

main returns 0 on success:
	0 is always success in UNIX, because there could be a lot of ways things fail, but only one where they succeed
