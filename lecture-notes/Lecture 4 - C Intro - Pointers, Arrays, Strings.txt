Variables:
	- A variable may be initialized in its declaration; if not, it holds garbage

Undefined behavior:
	- A lot of C has "undefined behavior". This means it is often unpredictable behavior
		- It will run one way one one computer ...
		- But some other way on another
		- Or even just be different each time the program is executed
	- Often characterized as "Heisenbugs"
		- Bugs that seem random/hard to reproduce, and seem to disappear or change when debugging
		- Cf. "Bohrbugs" which are repeatable

Pointers:
	int *p; -> tells compiler that variable p is address of an int
			p holds garbage at this point

	p = &y; -> tells compiler to assign address of y to p
			& called "address operator" in this context

	z = *p; -> tells compiler to assign value at address in p to z
			* called "dereference operator" in this context


	Example:
		void addOne(int *p) { *p = *p + 1; }

		int y = 3;
		addOne(&y);

	Why use pointers?
		- Avoid copying

	Drawback?
		- Dangling references and memory leaks


	Normally a pointer can only point to one type (int, struct, ...)
		- void * is a type that can point to anything (generic pointer)
		- use sparingly to help avoid program bugs and security issues and a lot of other bad things
	You can even have pointers to functions:
		int (*fn) (void *, void *) = &foo
		-> fn is a function that accepts two void * pointers and returns an int and is initially pointing to the function foo
		(*fn) (x, y) will then call the function

Null pointers:
	- If you write to or read a null pointer, your program should crash
	- Since "0 is false", it's very easy to do tests for null:
		if (!p) -> p is a null pointer
		if (p) -> p is not a null pointer

Pointing to different size objects:
	- Modern machines are "byte-addressable"
		-> Hardware's memory composed of 8-bit storage cells, each has a unique address
	- A C pointer is just abstracted memory address
	- Type declaration tells compiler how many bytes to fetch on each access through pointer
		Example: 32-bit integer stored in 4 consecutive bytes
	- But we actually want "word-alignment"
		- some processors will not allow you to address 32-bit values without being on 4 byte boundaries
		- others will just be very slow if you try to access "unaligned" memory

		Word alignment says you have to be aligned (on a 32b machine) to 0, 4, 8, 12, ...

sizeof()
	- By standard C99 definition, sizeof(char) == 1

	- sizeof(type) returns number of bytes in object
		- includes any padding needed for alignment
			-> Example: strcut {
							int x, -> this is 4 bytes
							char y -> this is 1 byte
						}
				sizeof of this struct is 8 because of padding

	Rule of thumb: sizeof(struct) is a multiple of the largest alignment of its members.

Arrays:
	int arr[2];
	int arr[] = { 1, 2 };

	Arrays are almost identical to pointers:
		char* string and char string[] are nearly identical declarations
		they differ in very subtle ways: incrementing, declaration of filled arrays

	Key Concept: An array variable is a "pointer" to the first element

	Consequences:
		arr[0] is the same as *arr
		arr[2] is the same as *(arr + 2)
		We can use pointer arithmetic to access arrays more conveniently

	Declared arrays are only allocated while the scope is valid:
		char *foo() {
			char string[32];
			return string;
		}
		-> incorrect, the space is only available in the subroutine (stack)

	Pitfall: An array in C does not know its own length, and bounds not checked!
		- Consequence: we can accidentally access off the end of an array
					   we must pass the array and its size to a procedure which is going to traverse it
						- Exception: strings: strings have a null terminator: you can read until you encounter 0
	Segmentation faults and bus errors: These are very difficult to find
		A segmentation fault says you are reading/writing to a memory you don't have access to (outside the segment)
		A bus error often means your alignment is wrong
			-> if the address of an int is not 0, 4, 8, or C, you are not word aligned -> bus error

	Pointer arithmetic:
		- pointer + n
			-> adds n * sizeof("whatever pointer is pointing to") to the memory address
		- pointer

	Changing a pointer:
		void incrementPtr(int **p) { *p = *p + 1; } -> p here is called a "handle"

		incrementPtr(&p);

